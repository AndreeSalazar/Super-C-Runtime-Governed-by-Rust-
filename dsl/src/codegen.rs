//! SuperC DSL Code Generator
//!
//! Traduce AST a código Rust/C que usa el runtime.

use crate::ast::*;

/// Target de generación de código
#[derive(Debug, Clone, Copy)]
pub enum CodegenTarget {
    Rust,
    C,
}

/// Generador de código
pub struct Codegen {
    target: CodegenTarget,
    indent: usize,
    output: String,
}

impl Codegen {
    pub fn new(target: CodegenTarget) -> Self {
        Self {
            target,
            indent: 0,
            output: String::new(),
        }
    }
    
    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }
    
    fn emit_line(&mut self, s: &str) {
        self.emit_indent();
        self.output.push_str(s);
        self.output.push('\n');
    }
    
    fn emit_indent(&mut self) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
    }
    
    fn indent(&mut self) {
        self.indent += 1;
    }
    
    fn dedent(&mut self) {
        if self.indent > 0 {
            self.indent -= 1;
        }
    }
    
    /// Genera código para un programa completo
    pub fn generate(&mut self, program: &Program) -> String {
        match self.target {
            CodegenTarget::Rust => self.gen_rust_program(program),
            CodegenTarget::C => self.gen_c_program(program),
        }
        std::mem::take(&mut self.output)
    }
    
    // ========================================================================
    // Rust Code Generation
    // ========================================================================
    
    fn gen_rust_program(&mut self, program: &Program) {
        self.emit_line("// Generated by SuperC DSL");
        self.emit_line("// DO NOT EDIT - This file is auto-generated");
        self.emit_line("");
        self.emit_line("use super_c_runtime::ffi::*;");
        self.emit_line("use super_c_runtime::arena::Arena;");
        self.emit_line("");
        
        // Generate functions
        for func in &program.functions {
            self.gen_rust_function(func);
            self.emit_line("");
        }
        
        // Generate main
        self.emit_line("fn main() {");
        self.indent();
        self.emit_line("// Initialize runtime");
        self.emit_line("let _config = super_c_runtime::RuntimeConfig::default();");
        self.emit_line("");
        
        for stmt in &program.statements {
            self.gen_rust_stmt(stmt);
        }
        
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_rust_function(&mut self, func: &FnDef) {
        self.emit_indent();
        self.emit(&format!("fn {}(", func.name));
        
        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                self.emit(", ");
            }
            self.emit(&format!("{}: {}", param.name, self.rust_type(&param.dtype)));
        }
        
        self.emit(")");
        if func.ret_type != DataType::Void {
            self.emit(&format!(" -> {}", self.rust_type(&func.ret_type)));
        }
        self.emit(" {\n");
        
        self.indent();
        for stmt in &func.body {
            self.gen_rust_stmt(stmt);
        }
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_rust_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::DataDecl { name, dtype } => {
                let rust_type = self.rust_type(dtype);
                let init = self.rust_default(dtype);
                self.emit_line(&format!("let mut {}: {} = {};", name, rust_type, init));
            }
            
            Stmt::Assign { target, index, value } => {
                self.emit_indent();
                if let Some(idx) = index {
                    self.emit(&format!("{}[", target));
                    self.gen_rust_expr(idx);
                    self.emit("] = ");
                } else {
                    self.emit(&format!("{} = ", target));
                }
                self.gen_rust_expr(value);
                self.emit(";\n");
            }
            
            Stmt::ExecBlock { target, body } => {
                match target {
                    ExecTarget::Parallel => {
                        self.emit_line("// Parallel execution (GPU if available)");
                        self.emit_line("unsafe {");
                        self.indent();
                        self.emit_line("if gpu_is_available() {");
                        self.indent();
                        for s in body {
                            self.gen_rust_stmt(s);
                        }
                        self.dedent();
                        self.emit_line("} else {");
                        self.indent();
                        for s in body {
                            self.gen_rust_stmt(s);
                        }
                        self.dedent();
                        self.emit_line("}");
                        self.dedent();
                        self.emit_line("}");
                    }
                    ExecTarget::Seq => {
                        self.emit_line("// Sequential CPU execution");
                        for s in body {
                            self.gen_rust_stmt(s);
                        }
                    }
                    ExecTarget::Gpu => {
                        self.emit_line("// GPU execution (required)");
                        self.emit_line("unsafe {");
                        self.indent();
                        for s in body {
                            self.gen_rust_stmt(s);
                        }
                        self.dedent();
                        self.emit_line("}");
                    }
                    ExecTarget::Asm => {
                        self.emit_line("// ASM-optimized CPU execution");
                        for s in body {
                            self.gen_rust_stmt(s);
                        }
                    }
                }
            }
            
            Stmt::If { cond, then_body, else_body } => {
                self.emit_indent();
                self.emit("if ");
                self.gen_rust_expr(cond);
                self.emit(" {\n");
                self.indent();
                for s in then_body {
                    self.gen_rust_stmt(s);
                }
                self.dedent();
                
                if let Some(else_stmts) = else_body {
                    self.emit_line("} else {");
                    self.indent();
                    for s in else_stmts {
                        self.gen_rust_stmt(s);
                    }
                    self.dedent();
                }
                self.emit_line("}");
            }
            
            Stmt::For { var, start, end, body } => {
                self.emit_indent();
                self.emit(&format!("for {} in ", var));
                self.gen_rust_expr(start);
                self.emit("..");
                self.gen_rust_expr(end);
                self.emit(" {\n");
                self.indent();
                for s in body {
                    self.gen_rust_stmt(s);
                }
                self.dedent();
                self.emit_line("}");
            }
            
            Stmt::ExprStmt(expr) => {
                self.emit_indent();
                self.gen_rust_expr(expr);
                self.emit(";\n");
            }
            
            Stmt::Return(value) => {
                self.emit_indent();
                if let Some(v) = value {
                    self.emit("return ");
                    self.gen_rust_expr(v);
                    self.emit(";\n");
                } else {
                    self.emit("return;\n");
                }
            }
        }
    }
    
    fn gen_rust_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::IntLit(n) => self.emit(&format!("{}", n)),
            Expr::FloatLit(n) => self.emit(&format!("{}f32", n)),
            Expr::BoolLit(b) => self.emit(&format!("{}", b)),
            Expr::StringLit(s) => self.emit(&format!("\"{}\"", s)),
            Expr::Ident(name) => self.emit(name),
            
            Expr::Index(arr, idx) => {
                self.gen_rust_expr(arr);
                self.emit("[");
                self.gen_rust_expr(idx);
                self.emit(" as usize]");
            }
            
            Expr::BinOp(left, op, right) => {
                self.emit("(");
                self.gen_rust_expr(left);
                self.emit(&format!(" {} ", self.rust_binop(op)));
                self.gen_rust_expr(right);
                self.emit(")");
            }
            
            Expr::UnaryOp(op, expr) => {
                self.emit(match op {
                    UnaryOp::Neg => "-",
                    UnaryOp::Not => "!",
                });
                self.gen_rust_expr(expr);
            }
            
            Expr::Call(name, args) => {
                self.emit(&format!("{}(", name));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_rust_expr(arg);
                }
                self.emit(")");
            }
            
            Expr::Reduce(op, arr) => {
                self.gen_rust_expr(arr);
                match op {
                    ReduceOp::Sum => self.emit(".iter().sum()"),
                    ReduceOp::Prod => self.emit(".iter().product()"),
                    ReduceOp::Max => self.emit(".iter().cloned().fold(f32::MIN, f32::max)"),
                    ReduceOp::Min => self.emit(".iter().cloned().fold(f32::MAX, f32::min)"),
                }
            }
        }
    }
    
    fn rust_type(&self, dtype: &DataType) -> String {
        match dtype {
            DataType::I32 => "i32".to_string(),
            DataType::I64 => "i64".to_string(),
            DataType::F32 => "f32".to_string(),
            DataType::F64 => "f64".to_string(),
            DataType::Bool => "bool".to_string(),
            DataType::Array(inner, size) => format!("[{}; {}]", self.rust_type(inner), size),
            DataType::Void => "()".to_string(),
        }
    }
    
    fn rust_default(&self, dtype: &DataType) -> String {
        match dtype {
            DataType::I32 => "0i32".to_string(),
            DataType::I64 => "0i64".to_string(),
            DataType::F32 => "0.0f32".to_string(),
            DataType::F64 => "0.0f64".to_string(),
            DataType::Bool => "false".to_string(),
            DataType::Array(inner, size) => format!("[{}; {}]", self.rust_default(inner), size),
            DataType::Void => "()".to_string(),
        }
    }
    
    fn rust_binop(&self, op: &BinOp) -> &'static str {
        match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Mod => "%",
            BinOp::Eq => "==",
            BinOp::NotEq => "!=",
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::LtEq => "<=",
            BinOp::GtEq => ">=",
            BinOp::And => "&&",
            BinOp::Or => "||",
        }
    }
    
    // ========================================================================
    // C Code Generation
    // ========================================================================
    
    fn gen_c_program(&mut self, program: &Program) {
        self.emit_line("/* Generated by SuperC DSL */");
        self.emit_line("/* DO NOT EDIT - This file is auto-generated */");
        self.emit_line("");
        self.emit_line("#include \"super_c.h\"");
        self.emit_line("#include \"gpu_unified.h\"");
        self.emit_line("#include <stdio.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("");
        
        // Generate functions
        for func in &program.functions {
            self.gen_c_function(func);
            self.emit_line("");
        }
        
        // Generate main
        self.emit_line("int main(void) {");
        self.indent();
        self.emit_line("// Initialize runtime");
        self.emit_line("native_init();");
        self.emit_line("gpu_init(GPU_PREFER_PERFORMANCE);");
        self.emit_line("");
        
        for stmt in &program.statements {
            self.gen_c_stmt(stmt);
        }
        
        self.emit_line("");
        self.emit_line("gpu_shutdown();");
        self.emit_line("native_shutdown();");
        self.emit_line("return 0;");
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_c_function(&mut self, func: &FnDef) {
        self.emit_indent();
        self.emit(&format!("{} {}(", self.c_type(&func.ret_type), func.name));
        
        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                self.emit(", ");
            }
            self.emit(&format!("{} {}", self.c_type(&param.dtype), param.name));
        }
        
        if func.params.is_empty() {
            self.emit("void");
        }
        
        self.emit(") {\n");
        
        self.indent();
        for stmt in &func.body {
            self.gen_c_stmt(stmt);
        }
        self.dedent();
        self.emit_line("}");
    }
    
    fn gen_c_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::DataDecl { name, dtype } => {
                let c_type = self.c_type(dtype);
                match dtype {
                    DataType::Array(_, size) => {
                        self.emit_line(&format!("{} {}[{}] = {{0}};", 
                            self.c_type(&DataType::F32), name, size));
                    }
                    _ => {
                        self.emit_line(&format!("{} {} = 0;", c_type, name));
                    }
                }
            }
            
            Stmt::Assign { target, index, value } => {
                self.emit_indent();
                if let Some(idx) = index {
                    self.emit(&format!("{}[", target));
                    self.gen_c_expr(idx);
                    self.emit("] = ");
                } else {
                    self.emit(&format!("{} = ", target));
                }
                self.gen_c_expr(value);
                self.emit(";\n");
            }
            
            Stmt::ExecBlock { target, body } => {
                match target {
                    ExecTarget::Parallel => {
                        self.emit_line("/* Parallel execution */");
                        self.emit_line("if (gpu_is_available()) {");
                        self.indent();
                        for s in body {
                            self.gen_c_stmt(s);
                        }
                        self.dedent();
                        self.emit_line("} else {");
                        self.indent();
                        for s in body {
                            self.gen_c_stmt(s);
                        }
                        self.dedent();
                        self.emit_line("}");
                    }
                    ExecTarget::Seq => {
                        self.emit_line("/* Sequential CPU */");
                        for s in body {
                            self.gen_c_stmt(s);
                        }
                    }
                    ExecTarget::Gpu => {
                        self.emit_line("/* GPU execution */");
                        for s in body {
                            self.gen_c_stmt(s);
                        }
                    }
                    ExecTarget::Asm => {
                        self.emit_line("/* ASM-optimized */");
                        for s in body {
                            self.gen_c_stmt(s);
                        }
                    }
                }
            }
            
            Stmt::If { cond, then_body, else_body } => {
                self.emit_indent();
                self.emit("if (");
                self.gen_c_expr(cond);
                self.emit(") {\n");
                self.indent();
                for s in then_body {
                    self.gen_c_stmt(s);
                }
                self.dedent();
                
                if let Some(else_stmts) = else_body {
                    self.emit_line("} else {");
                    self.indent();
                    for s in else_stmts {
                        self.gen_c_stmt(s);
                    }
                    self.dedent();
                }
                self.emit_line("}");
            }
            
            Stmt::For { var, start, end, body } => {
                self.emit_indent();
                self.emit(&format!("for (int {} = ", var));
                self.gen_c_expr(start);
                self.emit(&format!("; {} < ", var));
                self.gen_c_expr(end);
                self.emit(&format!("; {}++) {{\n", var));
                self.indent();
                for s in body {
                    self.gen_c_stmt(s);
                }
                self.dedent();
                self.emit_line("}");
            }
            
            Stmt::ExprStmt(expr) => {
                self.emit_indent();
                self.gen_c_expr(expr);
                self.emit(";\n");
            }
            
            Stmt::Return(value) => {
                self.emit_indent();
                if let Some(v) = value {
                    self.emit("return ");
                    self.gen_c_expr(v);
                    self.emit(";\n");
                } else {
                    self.emit("return;\n");
                }
            }
        }
    }
    
    fn gen_c_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::IntLit(n) => self.emit(&format!("{}", n)),
            Expr::FloatLit(n) => self.emit(&format!("{}f", n)),
            Expr::BoolLit(b) => self.emit(if *b { "1" } else { "0" }),
            Expr::StringLit(s) => self.emit(&format!("\"{}\"", s)),
            Expr::Ident(name) => self.emit(name),
            
            Expr::Index(arr, idx) => {
                self.gen_c_expr(arr);
                self.emit("[");
                self.gen_c_expr(idx);
                self.emit("]");
            }
            
            Expr::BinOp(left, op, right) => {
                self.emit("(");
                self.gen_c_expr(left);
                self.emit(&format!(" {} ", self.rust_binop(op)));
                self.gen_c_expr(right);
                self.emit(")");
            }
            
            Expr::UnaryOp(op, expr) => {
                self.emit(match op {
                    UnaryOp::Neg => "-",
                    UnaryOp::Not => "!",
                });
                self.gen_c_expr(expr);
            }
            
            Expr::Call(name, args) => {
                // Map common functions
                let c_name = match name.as_str() {
                    "print" => "printf",
                    "sqrt" => "sqrtf",
                    "sin" => "sinf",
                    "cos" => "cosf",
                    "exp" => "expf",
                    "log" => "logf",
                    _ => name,
                };
                self.emit(&format!("{}(", c_name));
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        self.emit(", ");
                    }
                    self.gen_c_expr(arg);
                }
                self.emit(")");
            }
            
            Expr::Reduce(op, arr) => {
                // Generate inline reduction
                self.emit("/* reduce */ 0"); // Placeholder
                let _ = (op, arr); // Suppress warning
            }
        }
    }
    
    fn c_type(&self, dtype: &DataType) -> String {
        match dtype {
            DataType::I32 => "int32_t".to_string(),
            DataType::I64 => "int64_t".to_string(),
            DataType::F32 => "float".to_string(),
            DataType::F64 => "double".to_string(),
            DataType::Bool => "int".to_string(),
            DataType::Array(inner, _) => format!("{}*", self.c_type(inner)),
            DataType::Void => "void".to_string(),
        }
    }
}
