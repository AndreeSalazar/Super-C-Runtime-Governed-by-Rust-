//! SuperC DSL ASM Code Generator
//!
//! Genera código NASM para Windows x64 desde el AST.

use crate::ast::*;

/// Generador de código ASM (NASM para Windows x64)
pub struct AsmCodegen {
    output: String,
    data_section: String,
    bss_section: String,
    label_counter: usize,
}

impl AsmCodegen {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            data_section: String::new(),
            bss_section: String::new(),
            label_counter: 0,
        }
    }
    
    fn new_label(&mut self, prefix: &str) -> String {
        self.label_counter += 1;
        format!(".{}_{}", prefix, self.label_counter)
    }
    
    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
    }
    
    fn emit_data(&mut self, s: &str) {
        self.data_section.push_str(s);
        self.data_section.push('\n');
    }
    
    fn emit_bss(&mut self, s: &str) {
        self.bss_section.push_str(s);
        self.bss_section.push('\n');
    }
    
    /// Genera código ASM para un programa
    pub fn generate(&mut self, program: &Program) -> String {
        // Header
        self.emit("; Generated by SuperC DSL");
        self.emit("; NASM syntax for Windows x64");
        self.emit("; Assemble: nasm -f win64 -o output.obj output.asm");
        self.emit("; Link: link output.obj /subsystem:console /entry:main");
        self.emit("");
        self.emit("default rel");
        self.emit("");
        
        // External functions
        self.emit("extern printf");
        self.emit("extern ExitProcess");
        self.emit("");
        
        // Process data declarations first
        for stmt in &program.statements {
            if let Stmt::DataDecl { name, dtype } = stmt {
                self.gen_data_decl(name, dtype);
            }
        }
        
        // Generate text section
        self.emit("section .text");
        self.emit("global main");
        self.emit("");
        
        // Generate functions
        for func in &program.functions {
            self.gen_function(func);
        }
        
        // Generate main
        self.emit("main:");
        self.emit("    push rbp");
        self.emit("    mov rbp, rsp");
        self.emit("    sub rsp, 32          ; Shadow space for Windows x64");
        self.emit("");
        
        for stmt in &program.statements {
            match stmt {
                Stmt::DataDecl { .. } => {} // Already processed
                _ => self.gen_stmt(stmt),
            }
        }
        
        self.emit("");
        self.emit("    xor ecx, ecx");
        self.emit("    call ExitProcess");
        self.emit("");
        
        // Combine sections
        let mut result = self.output.clone();
        
        if !self.data_section.is_empty() {
            result.push_str("\nsection .data\n");
            result.push_str(&self.data_section);
        }
        
        if !self.bss_section.is_empty() {
            result.push_str("\nsection .bss\n");
            result.push_str(&self.bss_section);
        }
        
        // Add format strings for printf
        result.push_str("\nsection .data\n");
        result.push_str("    fmt_float: db \"%.6f\", 10, 0\n");
        result.push_str("    fmt_int: db \"%lld\", 10, 0\n");
        
        result
    }
    
    fn gen_data_decl(&mut self, name: &str, dtype: &DataType) {
        match dtype {
            DataType::I32 => {
                self.emit_bss(&format!("    {}: resd 1", name));
            }
            DataType::I64 => {
                self.emit_bss(&format!("    {}: resq 1", name));
            }
            DataType::F32 => {
                self.emit_bss(&format!("    {}: resd 1", name));
            }
            DataType::F64 => {
                self.emit_bss(&format!("    {}: resq 1", name));
            }
            DataType::Bool => {
                self.emit_bss(&format!("    {}: resb 1", name));
            }
            DataType::Array(inner, size) => {
                let elem_size = match inner.as_ref() {
                    DataType::I32 | DataType::F32 => 4,
                    DataType::I64 | DataType::F64 => 8,
                    DataType::Bool => 1,
                    _ => 4,
                };
                self.emit_bss(&format!("    {}: resb {}", name, elem_size * size));
            }
            DataType::Void => {}
        }
    }
    
    fn gen_function(&mut self, func: &FnDef) {
        self.emit(&format!("{}:", func.name));
        self.emit("    push rbp");
        self.emit("    mov rbp, rsp");
        self.emit("    sub rsp, 32");
        
        for stmt in &func.body {
            self.gen_stmt(stmt);
        }
        
        self.emit("    add rsp, 32");
        self.emit("    pop rbp");
        self.emit("    ret");
        self.emit("");
    }
    
    fn gen_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::DataDecl { .. } => {} // Handled separately
            
            Stmt::Assign { target, index, value } => {
                self.gen_assign(target, index.as_ref(), value);
            }
            
            Stmt::ExecBlock { target, body } => {
                self.emit(&format!("    ; {} block", match target {
                    ExecTarget::Parallel => "parallel",
                    ExecTarget::Seq => "sequential",
                    ExecTarget::Gpu => "gpu",
                    ExecTarget::Asm => "asm-optimized",
                }));
                for s in body {
                    self.gen_stmt(s);
                }
            }
            
            Stmt::If { cond, then_body, else_body } => {
                let else_label = self.new_label("else");
                let end_label = self.new_label("endif");
                
                self.gen_expr_to_rax(cond);
                self.emit("    test rax, rax");
                self.emit(&format!("    jz {}", else_label));
                
                for s in then_body {
                    self.gen_stmt(s);
                }
                self.emit(&format!("    jmp {}", end_label));
                
                self.emit(&format!("{}:", else_label));
                if let Some(else_stmts) = else_body {
                    for s in else_stmts {
                        self.gen_stmt(s);
                    }
                }
                self.emit(&format!("{}:", end_label));
            }
            
            Stmt::For { var, start, end, body } => {
                let loop_label = self.new_label("loop");
                let end_label = self.new_label("endloop");
                
                // Initialize loop variable
                self.gen_expr_to_rax(start);
                self.emit(&format!("    mov [{}], rax", var));
                
                self.emit(&format!("{}:", loop_label));
                
                // Check condition
                self.emit(&format!("    mov rax, [{}]", var));
                self.gen_expr_to_rcx(end);
                self.emit("    cmp rax, rcx");
                self.emit(&format!("    jge {}", end_label));
                
                // Body
                for s in body {
                    self.gen_stmt(s);
                }
                
                // Increment
                self.emit(&format!("    inc qword [{}]", var));
                self.emit(&format!("    jmp {}", loop_label));
                
                self.emit(&format!("{}:", end_label));
            }
            
            Stmt::ExprStmt(expr) => {
                if let Expr::Call(name, args) = expr {
                    self.gen_call(name, args);
                }
            }
            
            Stmt::Return(value) => {
                if let Some(v) = value {
                    self.gen_expr_to_rax(v);
                }
                self.emit("    add rsp, 32");
                self.emit("    pop rbp");
                self.emit("    ret");
            }
        }
    }
    
    fn gen_assign(&mut self, target: &str, index: Option<&Expr>, value: &Expr) {
        if let Some(idx) = index {
            // Array assignment
            self.gen_expr_to_rax(idx);
            self.emit("    push rax          ; save index");
            self.gen_expr_to_xmm0(value);
            self.emit("    pop rcx           ; restore index");
            self.emit(&format!("    lea rax, [{}]", target));
            self.emit("    vmovss [rax + rcx*4], xmm0");
        } else {
            // Simple assignment
            self.gen_expr_to_xmm0(value);
            self.emit(&format!("    vmovss [{}], xmm0", target));
        }
    }
    
    fn gen_expr_to_rax(&mut self, expr: &Expr) {
        match expr {
            Expr::IntLit(n) => {
                self.emit(&format!("    mov rax, {}", n));
            }
            Expr::FloatLit(n) => {
                // Convert float to int bits
                let bits = (*n as f32).to_bits();
                self.emit(&format!("    mov eax, {}", bits));
            }
            Expr::BoolLit(b) => {
                self.emit(&format!("    mov rax, {}", if *b { 1 } else { 0 }));
            }
            Expr::Ident(name) => {
                self.emit(&format!("    mov rax, [{}]", name));
            }
            Expr::Index(arr, idx) => {
                if let Expr::Ident(name) = arr.as_ref() {
                    self.gen_expr_to_rax(idx);
                    self.emit(&format!("    lea rcx, [{}]", name));
                    self.emit("    mov eax, [rcx + rax*4]");
                }
            }
            Expr::BinOp(left, op, right) => {
                self.gen_expr_to_rax(left);
                self.emit("    push rax");
                self.gen_expr_to_rax(right);
                self.emit("    mov rcx, rax");
                self.emit("    pop rax");
                match op {
                    BinOp::Add => self.emit("    add rax, rcx"),
                    BinOp::Sub => self.emit("    sub rax, rcx"),
                    BinOp::Mul => self.emit("    imul rax, rcx"),
                    BinOp::Div => {
                        self.emit("    cqo");
                        self.emit("    idiv rcx");
                    }
                    BinOp::Mod => {
                        self.emit("    cqo");
                        self.emit("    idiv rcx");
                        self.emit("    mov rax, rdx");
                    }
                    BinOp::Eq => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    sete al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::NotEq => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    setne al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::Lt => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    setl al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::Gt => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    setg al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::LtEq => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    setle al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::GtEq => {
                        self.emit("    cmp rax, rcx");
                        self.emit("    setge al");
                        self.emit("    movzx rax, al");
                    }
                    BinOp::And => self.emit("    and rax, rcx"),
                    BinOp::Or => self.emit("    or rax, rcx"),
                }
            }
            _ => {
                self.emit("    xor rax, rax     ; unsupported expr");
            }
        }
    }
    
    fn gen_expr_to_rcx(&mut self, expr: &Expr) {
        self.gen_expr_to_rax(expr);
        self.emit("    mov rcx, rax");
    }
    
    fn gen_expr_to_xmm0(&mut self, expr: &Expr) {
        match expr {
            Expr::FloatLit(n) => {
                let bits = (*n as f32).to_bits();
                self.emit(&format!("    mov eax, {}", bits));
                self.emit("    vmovd xmm0, eax");
            }
            Expr::IntLit(n) => {
                self.emit(&format!("    mov eax, {}", n));
                self.emit("    vcvtsi2ss xmm0, xmm0, eax");
            }
            Expr::Ident(name) => {
                self.emit(&format!("    vmovss xmm0, [{}]", name));
            }
            Expr::Index(arr, idx) => {
                if let Expr::Ident(name) = arr.as_ref() {
                    self.gen_expr_to_rax(idx);
                    self.emit(&format!("    lea rcx, [{}]", name));
                    self.emit("    vmovss xmm0, [rcx + rax*4]");
                }
            }
            Expr::BinOp(left, op, right) => {
                self.gen_expr_to_xmm0(left);
                self.emit("    sub rsp, 16");
                self.emit("    vmovss [rsp], xmm0");
                self.gen_expr_to_xmm0(right);
                self.emit("    vmovss xmm1, xmm0, xmm0");
                self.emit("    vmovss xmm0, [rsp]");
                self.emit("    add rsp, 16");
                match op {
                    BinOp::Add => self.emit("    vaddss xmm0, xmm0, xmm1"),
                    BinOp::Sub => self.emit("    vsubss xmm0, xmm0, xmm1"),
                    BinOp::Mul => self.emit("    vmulss xmm0, xmm0, xmm1"),
                    BinOp::Div => self.emit("    vdivss xmm0, xmm0, xmm1"),
                    _ => {}
                }
            }
            _ => {
                self.emit("    vxorps xmm0, xmm0, xmm0  ; unsupported");
            }
        }
    }
    
    fn gen_call(&mut self, name: &str, args: &[Expr]) {
        match name {
            "print" => {
                if let Some(arg) = args.first() {
                    self.gen_expr_to_xmm0(arg);
                    self.emit("    vcvtss2sd xmm0, xmm0, xmm0  ; float to double for printf");
                    self.emit("    sub rsp, 32");
                    self.emit("    lea rcx, [fmt_float]");
                    self.emit("    movq rdx, xmm0");
                    self.emit("    call printf");
                    self.emit("    add rsp, 32");
                }
            }
            _ => {
                self.emit(&format!("    call {}", name));
            }
        }
    }
}

impl Default for AsmCodegen {
    fn default() -> Self {
        Self::new()
    }
}
